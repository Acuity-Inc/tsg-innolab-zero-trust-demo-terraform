import groovy.json.JsonSlurper

pipeline {
    agent any

    stages {
        stage('Retrieve Environment Variables') {
            steps {
                script {
                    try{
                        def ssmParameterNames = [
                        '/ztd/terraform/aws_s3_bucket',
                        '/ztd/terraform/aws_s3_key',
                        '/ztd/terraform/aws_s3_region',
                        '/ztd/terraform/aws_region',
                        '/ztd/terraform/okta_authorization_header',
                        '/ztd/terraform/okta_base_url',
                        '/ztd/terraform/okta_client_id',
                        '/ztd/terraform/okta_client_secret'
                        ]

                        def ssmCommand = "aws ssm get-parameters --names " +
                                        "${ssmParameterNames.join(" ")} " +
                                        "--with-decryption --output json"
                        
        
                        def ssmOutput = sh(script: ssmCommand, returnStdout: true).trim()
                        echo(ssmOutput)
                        def ssmJson = new JsonSlurper().parseText(ssmOutput)

                        // Assign the retrieved values to Jenkins environment variables
                        ssmParameterNames.each { parameterName ->
                            def parameterValue = ssmJson.Parameters.find { it.Name == parameterName }?.Value ?: ''
                            // Remove '/ztd/terraform/' prefix and convert to uppercase
                            def envVariableName = parameterName.replace('/ztd/terraform/', '').toUpperCase()
                            env."${envVariableName}" = parameterValue
                            // Log the value of '/ztd/terraform/aws_region'
                            echo "The value of ${envVariableName} is: ${parameterValue}"
                        }
                    } catch (Exception e){
                        echo "Error occurred while retrieving environment variables: ${e.message}"
                    }
                    
                }
            }
        }

        stage('Retrieve Okta API Token') {
            steps {
                script {
                    try{
                        // Get the client ID and client secret from the env variable
                        def plainText = "${env.OKTA_CLIENT_ID}:${env.OKTA_CLIENT_SECRET}"
                        def encodedText = plainText.bytes.encodeBase64().toString()
                        def escapedAuthHeader = "${encodedText}".replaceAll("'", "'\\\\''");

                        def curlCommand = "curl --silent --request POST --url ${env.OKTA_BASE_URL}/oauth2/default/v1/token --header 'accept: application/json' --header 'authorization: Basic ${escapedAuthHeader}' --header 'cache-control: no-cache' --header 'content-type: application/x-www-form-urlencoded' --data 'grant_type=client_credentials&scope=okta.myAccount.email.read'"
                        def tokenResponse = sh(script: curlCommand, returnStdout: true).trim()


                        // Parse the token from the response
                        def token = new JsonSlurper().parseText(tokenResponse).access_token

                        // Set the token as an environment variable
                        env.OKTA_API_TOKEN = token
                        echo "The Okta API token is: ${token}"
                        

                    } catch (Exception e){
                        echo "Error occurred while retrieving Okta API token: ${e.message}"
                    }
                    
                }
            }
        }

        stage('Create Docker Container') {
            steps {
                script {
                    try {
                        def containerName = 'terraform_container'
                        def existingContainerId = sh(script: "docker ps -aq -f name=${containerName}", returnStdout: true)

                        if (existingContainerId) {
                            echo "Container with name ${containerName} already exists with ID ${existingContainerId}"
                            env.TERRAFORM_CONTAINER_ID = existingContainerId
                            sh "docker logs ${exisingContainerId}"

                        } else {
                            echo "Container with name ${containerName} does not exist. Creating it..."

                            def dockerRunCommand = """
                                docker run -d \
                                -e AWS_S3_BUCKET=${env.AWS_S3_BUCKET} \
                                -e AWS_S3_KEY=${env.AWS_S3_KEY} \
                                -e AWS_S3_REGION=${env.AWS_S3_REGION} \
                                -e AWS_REGION=${env.AWS_REGION} \
                                -e OKTA_API_TOKEN=${env.OKTA_API_TOKEN} \
                                --name ${containerName} \
                                --entrypoint "/bin/sh" \
                                -v "${env.WORKSPACE}:/terraform" \
                                hashicorp/terraform:1.4.0 \
                                -c "cd terraform && sleep infinity"
                            """



                            // Run the Docker container and get the container ID
                            def containerId = sh(script: dockerRunCommand, returnStdout: true).trim()
                            sh "docker logs ${containerId}"
                            echo "Started Docker container with ID: ${containerId}"
                            // Check the status of the Docker container
                            sh "docker ps -a"

                            // Save the container ID for later stages
                            env.TERRAFORM_CONTAINER_ID = containerId
                        } 
                    }  catch(Exception e) {
                            echo "Error occurred while creating Docker container: ${e.message}"
                    }
                }
            }
        }   

        stage('Terraform Init') {
            steps {
                script {
                    sh 'docker ps -a'
                    echo(env.TERRAFORM_CONTAINER_ID)
                    try {
                        // Define the Docker exec command
                        def dockerExecCommand = """
                            docker exec ${env.TERRAFORM_CONTAINER_ID} \
                            sh -c "cd terraform && terraform init -backend-config='bucket=${env.AWS_S3_BUCKET}' -backend-config='key=${env.AWS_S3_KEY}' -backend-config='region=${env.AWS_S3_REGION}'"
                        """
                
                        // Execute the command in the Docker container
                        sh(script: dockerExecCommand)
                    } catch(Exception e) {
                        echo "Error occurred while running Terraform init: ${e.message}"
                    }
                }
            }
        }

        stage('Terraform Plan') {
            steps {
                script {
                    try{
                        // Define the Docker exec command
                        def dockerExecCommand = """
                            docker exec ${env.TERRAFORM_CONTAINER_ID} \
                            sh -c "cd terraform && terraform plan -var 'aws_region=${env.AWS_REGION}' -var 's3_bucket=${env.AWS_S3_BUCKET}' -var 's3_key=${env.AWS_S3_KEY}' -var 's3_region=${env.AWS_S3_REGION}' -var 'okta_api_token=${env.OKTA_API_TOKEN}' -out=tfplan"
                        """

                        // Execute the command in the Docker container
                        sh(script: dockerExecCommand)
                    } catch(Exception e) {
                        echo "Error occurred while running Terraform plan: ${e.message}"
                    }
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                script {
                    try{
                        // Define the Docker exec command
                        def dockerExecCommand = """
                            docker exec ${env.TERRAFORM_CONTAINER_ID} \
                            sh -c "cd terraform && terraform apply -auto-approve tfplan"
                        """

                        // Execute the command in the Docker container
                        sh(script: dockerExecCommand)
                    } catch(Exception e){
                        echo "Error occurred while running Terraform apply: ${e.message}"
                    }
                }   
            }
        }

        stage('Clean Up Docker Container') {
            steps {
                script {
                    try {
                        // If container is not null
                        if (env.TERRAFORM_CONTAINER_ID) {
                            // Stop the Docker container
                            sh(script: "docker stop ${env.TERRAFORM_CONTAINER_ID}")
                            // Remove the Docker container
                            sh(script: "docker rm ${env.TERRAFORM_CONTAINER_ID}")
                        }
                    } catch(Exception cleanupException) {
                        echo "Failed to cleanup Docker container: ${cleanupException.message}"
                    }
                }
            }
        }
    }
}