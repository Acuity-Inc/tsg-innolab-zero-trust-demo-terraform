import groovy.json.JsonSlurper

pipeline {
    agent any

    stages {
        stage('Retrieve Environment Variables') {
            steps {
                script {
                    try{
                        def ssmParameterNames = [
                        '/ztd/terraform/aws_s3_bucket',
                        '/ztd/terraform/aws_s3_key',
                        '/ztd/terraform/aws_s3_region',
                        '/ztd/terraform/aws_region',
                        '/ztd/terraform/okta_authorization_header',
                        '/ztd/terraform/okta_base_url',
                        ]

                        def ssmCommand = "aws ssm get-parameters --names " +
                                        "${ssmParameterNames.join(" ")} " +
                                        "--with-decryption --output json"
                        
        
                        def ssmOutput = sh(script: ssmCommand, returnStdout: true).trim()
                        echo(ssmOutput)
                        def ssmJson = new JsonSlurper().parseText(ssmOutput)

                        // Assign the retrieved values to Jenkins environment variables
                        ssmParameterNames.each { parameterName ->
                            def parameterValue = ssmJson.Parameters.find { it.Name == parameterName }?.Value ?: ''
                            // Remove '/ztd/terraform/' prefix and capitalize the letters
                            def envVariableName = parameterName - '/ztd/terraform/' - [/./, &.toUpperCase()]
                            env."${envVariableName}" = parameterValue
                            // Log the value of '/ztd/terraform/aws_region'
                            echo "The value of ${envVariableName} is: ${parameterValue}"
                }
                    } catch (Exception e){
                        echo "Error occurred while retrieving environment variables: ${e.message}"
                    }
                    
                }
            }
        }

        stage('Retrieve Okta API Token') {
            steps {
                script {
                    try{
                        // Execute curl command to retrieve API token
                        def curlCommand = "curl --silent --request POST --url ${env.OKTA_BASE_URL}/oauth2/default/v1/token --header 'accept: application/json' --header 'authorization: Basic ${env.OKTA_AUTHORIZATION_HEADER}' --header 'cache-control: no-cache' --header 'content-type: application/x-www-form-urlencoded' --data 'grant_type=client_credentials&scope=okta.myAccount.email.read'"
                        def tokenResponse = sh(script: curlCommand, returnStdout: true).trim()

                        // Parse the token from the response
                        def token = new JsonSlurper().parseText(tokenResponse).access_token

                        // Set the token as an environment variable
                        env.OKTA_API_TOKEN = token

                        

                    } catch (Exception e){
                        echo "Error occurred while retrieving Okta API token: ${e.message}"
                    }
                    
                }
            }
        }

        stage('Create Docker Container') {
            steps {
                script {
                    // Define the Docker container configuration
                    def containerConfig = [
                        image: 'hashicorp/terraform:1.4.0',
                        args: '-e AWS_S3_BUCKET=' + env.AWS_S3_BUCKET +
                              ' -e AWS_S3_KEY=' + env.AWS_S3_KEY +
                              ' -e AWS_S3_REGION=' + env.AWS_S3_REGION +
                              ' -e AWS_REGION=' + env.AWS_REGION +
                              ' -e OKTA_API_TOKEN=' + env.OKTA_API_TOKEN,
                        tty: true
                    ]

                    // Run the Docker container
                    container = docker.createContainer(containerConfig)
                    docker.startContainer(container.id)
                }
            }
        }

        stage('Terraform Init') {
            steps {
                script {
                    def execId = docker.containerExec(container.id, ['sh', '-c', "terraform init -backend-config=\"bucket=${env.AWS_S3_BUCKET}\" -backend-config=\"key=${env.AWS_S3_KEY}\" -backend-config=\"region=${env.AWS_S3_REGION}\""])
                    docker.containerExecStart(container.id, execId.id)
                }
            }
        }

        stage('Terraform Plan') {
            steps {
                script {
                    def execId = docker.containerExec(container.id, ['sh', '-c', "terraform plan -var \"aws_region=${env.AWS_REGION}\" -var \"s3_bucket=${env.AWS_S3_BUCKET}\" -var \"s3_key=${env.AWS_S3_KEY}\" -var \"s3_region=${env.AWS_S3_REGION}\" -var \"okta_api_token=${env.OKTA_API_TOKEN}\" -out=tfplan"])
                    docker.containerExecStart(container.id, execId.id)
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                script {
                    def execId = docker.containerExec(container.id, ['sh', '-c', 'terraform apply -auto-approve tfplan'])
                    docker.containerExecStart(container.id, execId.id)
                }
            }
        }

        stage('Clean Up Docker Container') {
            steps {
                script {
                    // Clean up the Docker container
                    if (container != null) {
                        try {
                            docker.stopContainer(container.id)
                            docker.removeContainer(container.id)
                        } catch(Exception cleanupException) {
                            echo "Failed to cleanup Docker container: ${cleanupException.message}"
                        }
                    }
                }
            }
        }
    }
}